#!/usr/bin/perl
#
# buildd-uploader: upload finished packages for buildd
# Copyright (C) 1998 Roman Hodek <Roman.Hodek@informatik.uni-erlangen.de>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; either version 2 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# $Id$
#

BEGIN {
	($main::HOME = $ENV{'HOME'})
		or die "HOME not defined in environment!\n";
	push( @INC, "$main::HOME/lib" );
}

use strict;
use Buildd;
$ENV{'PATH'} = "$main::HOME/bin:/usr/bin:/bin:/usr/local/bin";

read_config();

if ($sshsocket and -S "$main::HOME/build/$conf::sshsocket") {
	$sshcmd .= " -S $main::HOME/build/$conf::sshsocket";
}

$conf::dupload_to ||= "anonymous-ftp-master";
$conf::dupload_to_non_us ||= "anonymous-non-us";
$conf::dupload_to_security ||= "security";

lock_file( "$main::HOME/daemon.log" );
END { unlock_file( "$main::HOME/daemon.log" ); }
open_log();

upload( "upload-security", $conf::dupload_to_security );
upload( "upload", $conf::dupload_to );
upload( "upload-non-US", $conf::dupload_to_non_us );

my $dist;
my @propagated_pkgs = ();
foreach $dist (qw(oldstable-security stable stable-security testing testing-security unstable)) {
	next if !exists $main::done{$dist} || !@{$main::done{$dist}};
	logger( "Setting to Uploaded($dist): ",
			(map { my $x = $_; $x =~ s/_\S+\.changes$//; "$x "; }
				@{$main::done{$dist}}), "\n" );
	my $msgs = "";
	if (open( PIPE, "$conf::sshcmd wanna-build --uploaded --user=$conf::wanna_build_user ".
					($conf::wanna_build_dbbase?"--database=$conf::wanna_build_dbbase ":"").
					"--no-down-propagation --dist=$dist ".
					"@{$main::done{$dist}} 2>&1 |" )) {
		while( <PIPE> ) {
			if (/^(\S+): Propagating new state /) {
				push( @propagated_pkgs, $1 );
			}
			elsif (/^(\S+): already uploaded/ &&
				   isin( $1, @propagated_pkgs )) {
				# be quiet on this
			}
			else {
				$msgs .= $_;
			}
		}
		close( PIPE );
		logger( $msgs ) if $msgs;
		logger( "uploaded-build failed with status ", exitstatus($?), "\n" )
			if $?;
	}
	else {
		logger( "Cannot spawn uploaded-build: $!\n" );
	}
}

exit 0;


sub upload {
	my $udir = shift;
	my $upload_to = shift;
	
	chdir( "$main::HOME/$udir" ) || return;
	lock_file( "$main::HOME/$udir" );

	my( $f, $g, @before, @after );
	foreach $f (<*.changes>) {
		($g = $f) =~ s/\.changes$/\.upload/;
		push( @before, $f ) if ! -f $g;
	}
	if (!@before) {
		logger( "Nothing to do for $udir\n" );
		unlock_file( "$main::HOME/$udir" );
		return;
	}

	logger( scalar(@before), " jobs to upload in $udir: @before\n" );
	do_dupload( $upload_to, @before );

	foreach $f (<*.changes>) {
		($g = $f) =~ s/\.changes$/\.upload/;
		push( @after, $f ) if ! -f $g;
	}
	if (@after) {
		logger( "The following jobs were not processed (successfully):\n".
				"@after\n" );
	}
	else {
		logger( "dupload successful.\n" );
	}
	unlock_file( "$main::HOME/$udir" );
	write_stats( "uploads", scalar(@before) - scalar(@after) );

	foreach $f (@before) {
		next if isin( $f, @after );
		if (!open( F, "<$f" )) {
			logger( "Cannot open $f: $!\n" );
			next;
		}
		my $text;
		{ local($/); undef $/; $text = <F>; }
		close( F );
		if ($text !~ /^Distribution:\s*(.*)\s*$/m) {
			logger( "$f doesn't have a Distribution: field\n" );
			next;
		}
		my @dists = split( /\s+/, $1 );
		foreach (@dists) {
			push( @{$main::done{$_}}, $f );
		}
	}
}

sub do_dupload {
	my $upload_to = shift;
	my @jobs = @_;
	local( *PIPE );
	my( $current_job, $current_file, @failed, $errs );

	if (!open( PIPE, "dupload -k --to $upload_to @jobs </dev/null 2>&1 |" )) {
 		logger( "Cannot spawn dupload: $!\n" );
		return;
	}

	my $dup_log = "";
	while( <PIPE> ) {
		$dup_log .= $_;
		chomp;
		if (/^\[ job \S+ from (\S+\.changes)$/) {
			$current_job = $1;
		}
		elsif (/^warning: MD5sum mismatch for (\S+), skipping/i) {
			my $f = $1;
			logger( "dupload error: md5sum mismatch for $f\n" );
			$errs .= "md5sum mismatch on file $f ($current_job)\n";
			push( @failed, $current_job );
		}
		elsif (/^\[ Uploading job (\S+)$/) {
			$current_job = "$1.changes";
		}
		elsif (/^warning: dupload: Can't upload (\S+)/i ||
			   /^\s(\S+).*scp: (.*)$/) {
			my($f, $e) = ($1, $2);
			logger( "dupload error: upload error for $f\n" );
			logger( "($e)\n" ) if $e;
			$errs .= "upload error on file $f ($current_job)\n";
			push( @failed, $current_job );
		}
		elsif (/^\s(\S+)\s+[\d.]+ kB /) {
			$current_file = $1;
		}
	}
	close( PIPE );
	if ($?) {
		if (($? >> 8) == 141) {
			logger( "dupload error: SIGPIPE (broken connection)\n" );
			$errs .= "upload error (broken connection) during ".
					 "file $current_file ($current_job)\n";
			push( @failed, $current_job );
		}
		else {
			logger( "dupload exit status ", exitstatus($?), "\n" );
			$errs .= "dupload exit status ".exitstatus($?)."\n";
		}
	}

	foreach (@failed) {
		my $u;
		($u = $_) =~ s/\.changes$/\.upload/;
		unlink( $u );
		logger( "Removed $u due to upload errors.\n" );
		$errs .= "Removed $u to reupload later.\n";
	}

	if ($errs) {
		$errs .= "\nComplete output from dupload:\n\n$dup_log";
		send_mail( $conf::admin_mail, "dupload errors", $errs );
	}
}
