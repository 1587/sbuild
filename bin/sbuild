#! /usr/bin/perl
#
# sbuild: build packages, obeying source dependencies
# Copyright © 1998-2000 Roman Hodek <Roman.Hodek@informatik.uni-erlangen.de>
# Copyright © 2005      Ryan Murray <rmurray@debian.org>
# Copyright © 2005-2008 Roger Leigh <rleigh@debian.org
# Copyright © 2008      Timothy G Abbott <tabbott@mit.edu>
# Copyright © 2008      Simon McVittie <smcv@debian.org>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see
# <http://www.gnu.org/licenses/>.
#
#######################################################################

package conf;

use Sbuild::Conf;


package main;

use strict;
use warnings;
use POSIX;
use File::Basename qw(basename dirname);
use IO::Handle;
use FileHandle;
use Sbuild qw(binNMU_version version_compare copy);
use Data::Dumper;
use File::Temp qw(tempdir);
use Getopt::Long qw(:config no_ignore_case auto_abbrev gnu_getopt);
use Sbuild::Chroot;
use Sbuild::Log qw(open_log close_log open_pkg_log close_pkg_log);
use Sbuild::Sysconfig qw($arch $hostname $version);
use Sbuild::Build;

sub main ($);
sub shutdown ($);
sub check_group_membership ();
sub dump_main_state ();

sub main ($) {
    my $self = shift;

# Be verbose by default if on a tty
    if (-t STDIN && -t STDOUT && $Sbuild::Conf::verbose == 0) {
	$conf::verbose = 1;
    }

    exit 1 if !GetOptions ("arch=s" => \$self->{'User Arch'},
			   "A|arch-all" => sub {
			       $self->{'Build Arch All'} = 1
			   },
			   "auto-give-back=s" => sub {
			       $self->{'Auto Giveback'} = 1;
			       if ($_[1]) {
				   my @parts = split( '@', $_[1] );
				   $self->{'Auto Giveback Socket'} =
				       $parts[$#parts-3] if @parts > 3;
				   $self->{'Auto Giveback WannaBuild User'} =
				       $parts[$#parts-2] if @parts > 2;
				   $self->{'Auto Giveback User'} =
				       $parts[$#parts-1] if @parts > 1;
				   $self->{'Auto Giveback Host'} =
				       $parts[$#parts];
			       }
			   },
			   "f|force-depends=s" => sub {
			       push( @{$self->{'Manual Srcdeps'}}, "f".$_[1] );
			   },
			   "a|add-depends=s" => sub {
			       push( @{$self->{'Manual Srcdeps'}}, "a".$_[1] );
			   },
			   "check-depends-algorithm=s" => sub {
			       die "Bad build dependency check algorithm\n"
				   if( ! ($_[1] eq "first-only" 
					  || $_[1] eq "alternatives") );
			       $conf::check_depends_algorithm = $_[1];
			   },
			   "b|batch" => sub {
			       $self->{'Batch Mode'} = 1
			   },
			   "make-binNMU=s" => sub {
			       $self->{'binNMU'} = $_[1];
			       $self->{'binNMU Version'} ||= 1;
			   },
			   "binNMU=i" => sub {
			       $self->{'binNMU Version'} = $_[1];
			   },
			   "c|chroot=s" => sub {
			       $self->{'Chroot'} = $_[1];
			   },
			   "database=s" => sub {
			       $self->{'WannaBuild Database'} = $_[1]
			   },
			   "D|debug+" => \$conf::debug,
			   "apt-update" => \$conf::apt_update,
			   "d|dist=s" => sub {
			       $self->{'Distribution'} = $_[1];
			       $self->{'Distribution'} = "oldstable"
				   if $self->{'Distribution'} eq "o";
			       $self->{'Distribution'} = "stable"
				   if $self->{'Distribution'} eq "s";
			       $self->{'Distribution'} = "testing"
				   if $self->{'Distribution'} eq "t";
			       $self->{'Distribution'} = "unstable"
				   if $self->{'Distribution'} eq "u";
			       $self->{'Distribution'} = "experimental"
				   if $self->{'Distribution'} eq "e";
			       $self->{'Override Distribution'} = 1;
			   },
			   "force-orig-source" => \$conf::force_orig_source,
			   "m|maintainer=s" => \$conf::maintainer_name,
			   "k|keyid=s" => \$conf::key_id,
			   "e|uploader=s" => \$conf::uploader_name,
			   "n|nolog" => \$conf::nolog,
			   "purge=s" => sub {
			       $conf::purge_build_directory = $_[1];
			       die "Bad purge mode\n"
				   if !isin($conf::purge_build_directory,
					    qw(always successful never));
			   },
			   "s|source" => sub {
			       $self->{'Build Source'} = 1
			   },
			   "stats-dir=s" => \$conf::stats_dir,
			   "use-snapshot" => sub {
			       $self->{'GCC Snapshot'} = 1;
			       $self->{'LD_LIBRARY_PATH'} =
				   "/usr/lib/gcc-snapshot/lib";
			       $conf::path =
				   "/usr/lib/gcc-snapshot/bin:$conf::path";
			   },
			   "v|verbose+" => \$Sbuild::Conf::verbose,
			   "q|quiet" => sub {
			       $Sbuild::Conf::verbose-- if $conf::verbose;
			   },
	);

    print "Selected distribution $self->{'Distribution'}\n"
	if $conf::debug;
    print "Selected chroot $self->{'Chroot'}\n"
	if $conf::debug and defined $self->{'Chroot'};
    print "Selected architecture $self->{'User Arch'}\n"
	if $conf::debug;

    $conf::mailto = $conf::mailto{$self->{'Distribution'}}
    if $conf::mailto{$self->{'Distribution'}};

# see debsign for priorities, we will follow the same order
    $self->{'Signing Options'}="-m\"".$conf::maintainer_name."\"" if defined $conf::maintainer_name;
    $self->{'Signing Options'}="-e\"".$conf::uploader_name."\"" if defined $conf::uploader_name;
    $self->{'Signing Options'}="-k\"".$conf::key_id."\"" if defined $conf::key_id;
    $conf::maintainer_name=$conf::uploader_name if defined $conf::uploader_name;
    $conf::maintainer_name=$conf::key_id if defined $conf::key_id;

    if (!defined($conf::maintainer_name) &&
	!defined($conf::uploader_name) &&
	!defined($conf::key_id) ) {
	die "A maintainer name, uploader name or key ID must be specified in .sbuildrc,\nor use -m, -e or -k\n";
    }

# variables for scripts:
    open_log($self->{'Distribution'});
    $SIG{'INT'} = \&shutdown;
    $SIG{'TERM'} = \&shutdown;
    $SIG{'ALRM'} = \&shutdown;
    $SIG{'PIPE'} = \&shutdown;

    $self->parse_manual_srcdeps(map { m,(?:.*/)?([^_/]+)[^/]*, } @ARGV);

    $self->write_jobs_file("");

    my $dscfile;
    foreach $dscfile (@ARGV) {

	my $dir = dirname($dscfile);
	my $dscbase = basename($dscfile);
	my $pkgv = basename($dscfile);
	$pkgv =~ s/\.dsc$//;
	my ($pkg, $version) = split /_/, $pkgv;
	my $invalid = 0;

	# Download if package does not have a .dsc extension and no
	# directory was specified.
	my $download = 1;
	if ($dscbase =~ m/\.dsc$/) {
	    $download = 0;
	    if( ! -f $dscfile ) {
		$invalid = 1;
	    }
	}
	elsif( ! defined $version ) {
	    $invalid = 1;
	}

	print STDERR "D: dscfile = $dscfile\n" if $conf::debug;
	print STDERR "D: dir = $dir\n" if $conf::debug;
	print STDERR "D: dscbase = $dscbase\n" if $conf::debug;
	print STDERR "D: pkgv = $pkgv\n" if $conf::debug;
	print STDERR "D: pkg = $pkg\n" if $conf::debug;
	print STDERR "D: version = $version\n" if $conf::debug;
	print STDERR "D: download = $download\n" if $conf::debug;

	if ($invalid || ($download && $dscfile ne $pkgv)) {
	    print PLOG "Invalid source: $dscfile\n";
	    print PLOG "Skipping $pkg\n";
	    $self->{'Pkg Status'} = "skipped";
	    goto cleanup_close;
	}

	{
	    my $tpkg = basename($pkgv);
	    # TODO: This should be 'Pkg Start Time', set in build().
	    my $date = strftime("%Y%m%d-%H%M",localtime);

	    if ($self->{'binNMU'}) {
		$tpkg =~ /^([^_]+)_([^_]+)(.*)$/;
		$tpkg = $1 . "_" . binNMU_version($2,$self->{'binNMU Version'});
		$self->{'binNMU Name'} = $tpkg;
		$tpkg .= $3;
	    }

	    next if !$self->open_build_log($tpkg, $self->{'Distribution'}, $date );
	}

	$self->{'Pkg Status'} = "failed"; # assume for now
	$main::current_job = $pkgv;
	$self->{'Additional Deps'} = [];
	$self->write_jobs_file("currently building");
	if ($self->should_skip($pkgv)) {
	    $self->{'Pkg Status'} = "skipped";
	    goto cleanup_close;
	}

	my $session = Sbuild::Chroot::new($self->{'Distribution'},
					  $self->{'Chroot'},
					  $self->{'User Arch'});
	$self->{'Session'} = $session;

	if (!$session->begin_session()) {
	    print PLOG "Error creating schroot session: skipping $pkg\n";
	    $self->{'Pkg Status'} = "skipped";
	    goto cleanup_close;
	}
	$self->{'Chroot Dir'} = $session->{'Location'};
	$self->{'Chroot Build Dir'} = tempdir("$Sbuild::Conf::username-$pkgv-$arch-XXXXXX" , DIR => $session->{'Build Location'});
	# TODO: Don't hack the build location in; add a means to customise
	# the chroot directly.
	$session->{'Build Location'} = $self->{'Chroot Build Dir'};

	$self->{'Arch'} = $self->chroot_arch();

	# Update APT cache.
	if ($conf::apt_update) {
	    if (!open(PIPE, $session->get_apt_command("$conf::apt_get", "-q update", "root", 1, '/') . " 2>&1 |")) {
		print PLOG "Can't open pipe to apt-get: $!\n";
		return 0;
	    }
	    while(<PIPE>) {
		print PLOG $_;
	    }
	    close(PIPE);
	    if ($?) {
		print PLOG "apt-get update failed\n" ;
		$self->{'Pkg Status'} = "skipped";
		goto cleanup_close;
	    }
	}

	$self->{'Pkg Fail Stage'} = "fetch-src";
	if (!$self->fetch_source_files(\$dscfile,
				       $dir, $pkg, $version, $download)) {
	    goto cleanup_close;
	}

	$self->{'Pkg Fail Stage'} = "install-deps";
	if (!$self->install_deps($pkg)) {
	    print PLOG "Source-dependencies not satisfied; skipping $pkg\n";
	    goto cleanup_packages;
	}

	$self->{'Pkg Status'} = "successful"
	    if $self->build(basename($dscfile), $pkgv);
	$self->write_jobs_file($self->{'Pkg Status'});
	$self->append_to_FINISHED($pkgv);

      cleanup_packages:
	if (defined ($session->{'Session Cloned'}) &&
	    $session->{'Session Cloned'} == 1) {
	    print PLOG "Not removing build depends: cloned chroot in use\n";
	} else {
	    $self->uninstall_deps();
	}
	$self->remove_srcdep_lock_file();
      cleanup_close:
	$self->analyze_fail_stage($pkgv);
	$self->write_jobs_file($self->{'Pkg Status'});

	$session->end_session();
	$session = undef;
	$self->{'Session'} = undef;

	$self->close_build_log($main::current_job,
			       $self->{'Distribution'},
			       $self->{'Pkg Status'},
			       $self->{'Pkg Start Time'},
			       $self->{'Pkg End Time'},
			       $self->{'This Space'} );
	undef $self->{'binNMU Name'};
	$main::current_job = "";
	if ( $self->{'Batch Mode'} and (-f "$conf::HOME/EXIT-DAEMON-PLEASE") ) {
	    main::shutdown("NONE (flag file exit)");
	}
	dump_main_state() if $conf::debug;
    }
    $self->write_jobs_file("");

    close_log();
    unlink( $self->{'Jobs File'} ) if $self->{'Batch Mode'};
    unlink( "SBUILD-FINISHED" ) if $self->{'Batch Mode'};
    if ($conf::sbuild_mode eq "user") {
	exit ($self->{'Pkg Status'} ne "successful") ? 1 : 0;
    }
    exit 0;
}

sub shutdown ($) {
    my $signame = shift;
    my($job,@npkgs,@pkgs);
    local( *F );

    $SIG{'INT'} = 'IGNORE';
    $SIG{'QUIT'} = 'IGNORE';
    $SIG{'TERM'} = 'IGNORE';
    $SIG{'ALRM'} = 'IGNORE';
    $SIG{'PIPE'} = 'IGNORE';
    print PLOG "sbuild received SIG$signame -- shutting down\n";

    goto not_ni_shutdown if !$main::build_object->{'Batch Mode'};

    # most important: dump out names of unfinished jobs to REDO
    foreach $job (@ARGV) {
	my $job2 = $job;
	$main::build_object->fixup_pkgv(\$job2);
	push( @npkgs, $job2 )
	    if !$main::job_state{$job} || $job eq $main::current_job;
    }
    print LOG "The following jobs were not finished: @npkgs\n";

    my $f = "REDO";
    if (-f "REDO.lock") {
	# if lock file exists, write to a different file -- timing may
	# be critical
	$f = "REDO2";
    }
    if (open( F, "<$f" )) {
	@pkgs = <F>;
	close( F );
    }
    if (open( F, ">>$f" )) {
	foreach $job (@npkgs) {
	    next if grep( /^\Q$job\E\s/, @pkgs );
	    if (not defined $main::build_object->{'binNMU Version'}) {
		print F "$job $main::build_object->{'Distribution'}\n";
	    } else {
		print F "$job $main::build_object->{'Distribution'} $main::build_object->{'binNMU Version'} $main::build_object->{'binNMU'}\n";
	    }
	}
	close( F );
    }
    else {
	print "Cannot open $f: $!\n";
    }
    open( F, ">SBUILD-REDO-DUMPED" );
    close( F );
    print LOG "SBUILD-REDO-DUMPED created\n";
    unlink( "SBUILD-FINISHED" );

    # next: say which packages should be uninstalled
    @pkgs = keys %{$main::build_object->{'Changes'}->{'installed'}};
    if (@pkgs) {
	if (open( F, ">>NEED-TO-UNINSTALL" )) {
	    print F "@pkgs\n";
	    close( F );
	}
	print "The following packages still need to be uninstalled ",
	"(--purge):\n@pkgs\n";
    }

  not_ni_shutdown:
    # next: kill currently running command (if one)
    if ($main::build_object->{'Sub PID'}) {
	print "Killing $main::build_object->{'Sub Task'} subprocess $main::build_object->{'Sub PID'}\n";
	run_command("perl -e \"kill( \\\"TERM\\\", $main::build_object->{'Sub PID'} )\"", "root", 1, 0, '/');
    }
    $main::build_object->remove_srcdep_lock_file();

    # close logs and send mails
    if ( $main::current_job && defined($main::build_object->{'Session'})) {
	if ($conf::purge_build_directory eq "always") {
	    print PLOG "Purging $main::build_object->{'Chroot Build Dir'}\n";
	    my $bdir = $main::build_object->{'Session'}->strip_chroot_path($main::build_object->{'Chroot Build Dir'});
	    $main::build_object->{'Session'}->run_command("rm -rf '$bdir'", "root", 1, 0, '/');
	}

	$main::build_object->fixup_pkgv(\$main::current_job);

	$main::build_object->{'Session'}->end_session();
	undef $main::build_object->{'Session'};

	$main::build_object->close_build_log(
	    $main::current_job,
	    $main::build_object->{'Distribution'},
	    $main::build_object->{'Pkg Status'},
	    $main::build_object->{'Pkg Start Time'},
	    $main::build_object->{'Pkg End Time'},
	    $main::build_object->{'This Space'});
	undef $main::build_object->{'binNMU Name'};
    }
    close_log();
    unlink( $main::build_object->{'Jobs File'} ) if $main::build_object->{'Batch Mode'};
    $? = 0; $! = 0;
    if ($conf::sbuild_mode eq "user") {
	exit 1;
    }
    exit 0;
}

sub check_group_membership () {
    my $user = getpwuid($<);
    my ($name,$passwd,$gid,$members) = getgrnam("sbuild");

    if (!$gid) {
	die "Group sbuild does not exist";
    }

    my $in_group = 0;
    foreach (split(' ', $members)) {
	$in_group = 1 if $_ eq $Sbuild::Conf::username;
    }

    if (!$in_group) {
	print STDERR "User $user is not a member of group $name\n";
	print STDERR "See \"User Setup\" in sbuild-setup(7)\n";
	exit(1);
    }

    return;
}

sub dump_main_state () {
    my $self = shift;

    print STDERR Data::Dumper->Dump([$main::current_job,
				     $main::DEVNULL,
				     \%main::job_state],
				    [qw($main::current_job
					$main::DEVNULL
					%main::job_state)] );
}


$ENV{'LC_ALL'} = "POSIX";
$ENV{'SHELL'} = "/bin/sh";

# avoid intermixing of stdout and stderr
$| = 1;
# in case the terminal disappears, the build should continue
$SIG{'HUP'} = 'IGNORE';

# A file representing /dev/null
if (!open(main::DEVNULL, '+<', '/dev/null')) {
    die "Cannot open /dev/null: $!\n";;
}

check_group_membership();

umask(022);

$main::build_object = Sbuild::Build::new();

main($main::build_object);
